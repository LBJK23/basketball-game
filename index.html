<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Basketball Arcade Buttons</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; position: fixed;
            touch-action: none; -webkit-user-select: none;
            font-family: sans-serif;
        }
        canvas { 
            display: block; width: 100vw; height: 100vh; 
            object-fit: contain; background: #000; 
        }
        #rotate-warning {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: white; text-align: center; z-index: 1000;
            flex-direction: column; justify-content: center; align-items: center;
        }
        @media (orientation: portrait) { #rotate-warning { display: flex; } }
    </style>
</head>
<body>
    <div id="rotate-warning">
        <h2>üèÄ –ü–µ—Ä–µ–≤–µ—Ä–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω</h2>
        <p>–î–ª—è –∏–≥—Ä—ã –Ω—É–∂–µ–Ω –∞–ª—å–±–æ–º–Ω—ã–π —Ä–µ–∂–∏–º</p>
    </div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// –ë–∞–∑–æ–≤–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∏–≥—Ä—ã
const W = 1280, H = 720;
canvas.width = W; canvas.height = H;

const FLOOR_Y = 650;
const hoop = { x: 640, y: 300, z: 120 };

const courtImg = new Image();
courtImg.src = "Basketball-Court-vector-illustra.jpg";

let state = "MOVE"; 
let score = 0;
let powerPoint = 0, powerDir = 0.008, resultText = "";
const gravity = 0.45;
const ball = { x: 640, y: 600, z: 0, vx: 0, vy: 0, vz: 0, r: 22, active: false, bounced: false, isPerfect: false };

// –ù–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–Ω–æ–ø–∫–∞–º–∏
let playerPos = W / 2; // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞
let aimAngle = Math.PI / 2; // –£–≥–æ–ª –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è (0 - –≤–ø—Ä–∞–≤–æ, PI - –≤–ª–µ–≤–æ, PI/2 - –ø—Ä—è–º–æ)
let aimTargetX = hoop.x; // –¶–µ–ª—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –ø–æ X
let aimTargetY = hoop.y; // –¶–µ–ª—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –ø–æ Y

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–Ω–æ–ø–æ–∫
const BUTTON_SIZE = 80;
const BUTTON_PADDING = 20;

const buttons = {
    left: { x: W - BUTTON_SIZE * 3 - BUTTON_PADDING * 3, y: H - BUTTON_SIZE - BUTTON_PADDING, w: BUTTON_SIZE, h: BUTTON_SIZE, action: "moveLeft" },
    right: { x: W - BUTTON_SIZE * 2 - BUTTON_PADDING * 2, y: H - BUTTON_SIZE - BUTTON_PADDING, w: BUTTON_SIZE, h: BUTTON_SIZE, action: "moveRight" },
    aimLeft: { x: W - BUTTON_SIZE * 3 - BUTTON_PADDING * 3, y: H - BUTTON_SIZE * 2 - BUTTON_PADDING * 2, w: BUTTON_SIZE, h: BUTTON_SIZE, action: "aimLeft" },
    aimRight: { x: W - BUTTON_SIZE * 2 - BUTTON_PADDING * 2, y: H - BUTTON_SIZE * 2 - BUTTON_PADDING * 2, w: BUTTON_SIZE, h: BUTTON_SIZE, action: "aimRight" },
    shoot: { x: BUTTON_PADDING, y: H - BUTTON_SIZE - BUTTON_PADDING, w: BUTTON_SIZE * 1.5, h: BUTTON_SIZE * 1.5, action: "shoot" } // –ë–æ–ª—å—à–∞—è –∫–Ω–æ–ø–∫–∞-–º—è—á
};

/* ================= INPUT ENGINE (BUTTONS) ================= */
function isPointInRect(px, py, rx, ry, rw, rh) {
    return px > rx && px < rx + rw && py > ry && py < ry + rh;
}

function handleButtonPress(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    const clickX = (clientX - rect.left) * scaleX;
    const clickY = (clientY - rect.top) * scaleY;

    if (audioCtx.state === 'suspended') audioCtx.resume(); // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –∑–≤—É–∫

    for (const key in buttons) {
        const btn = buttons[key];
        if (isPointInRect(clickX, clickY, btn.x, btn.y, btn.w, btn.h)) {
            performAction(btn.action);
            return; // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –Ω–∞–∂–∞—Ç–∏–µ
        }
    }
}

function performAction(action) {
    switch (action) {
        case "moveLeft":
            if (state === "MOVE") playerPos = Math.max(200, playerPos - 15);
            break;
        case "moveRight":
            if (state === "MOVE") playerPos = Math.min(W - 200, playerPos + 15);
            break;
        case "aimLeft":
            if (state === "AIM_LINE") aimAngle = Math.min(Math.PI * 0.8, aimAngle + 0.05); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —É–≥–æ–ª
            break;
        case "aimRight":
            if (state === "AIM_LINE") aimAngle = Math.max(Math.PI * 0.2, aimAngle - 0.05); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —É–≥–æ–ª
            break;
        case "shoot":
            if (state === "MOVE") {
                state = "AIM_LINE";
            } else if (state === "AIM_LINE") {
                // –§–∏–∫—Å–∏—Ä—É–µ–º —Ç–µ–∫—É—â—É—é —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é –∫–∞–∫ —Ü–µ–ª–µ–≤—É—é
                // –î–ª—è –ø–∞—Ä–∞–±–æ–ª—ã –Ω—É–∂–Ω–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –∏ —É–≥–æ–ª
                const dist = Math.abs(hoop.x - ball.x);
                aimTargetX = ball.x + Math.cos(aimAngle) * dist * 1.5; // –£–ø—Ä–∞–≤–ª—è–µ–º X-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–º
                aimTargetY = ball.y - Math.sin(aimAngle) * dist * 1.5; // –£–ø—Ä–∞–≤–ª—è–µ–º Y-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–º
                state = "TIMING";
                powerPoint = 0;
            } else if (state === "TIMING") {
                shoot(powerPoint > 0.75);
                state = "SHOT";
            } else if (state === "RESULT") {
                state = "MOVE";
                ball.active = false;
                resultText = "";
            }
            break;
    }
}

// TOUCH Events
canvas.addEventListener("touchstart", e => { e.preventDefault(); handleButtonPress(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
// MOUSE Events (–¥–ª—è –ü–ö)
canvas.addEventListener("mousedown", e => handleButtonPress(e.clientX, e.clientY));

/* ================= AUDIO & VIBRATE ================= */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, duration) {
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = "triangle"; o.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(0.1, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + duration);
}
function vibrate(ms) { if (navigator.vibrate) navigator.vibrate(ms); }

/* ================= GAME LOGIC ================= */
function shoot(perfect) {
    ball.active = true; ball.bounced = false; ball.isPerfect = perfect;
    const T = 75;
    ball.vx = (hoop.x - ball.x) / T;
    ball.vz = (hoop.z - ball.z) / T;
    const heightErr = perfect ? 0 : (0.75 - powerPoint) * 10;
    ball.vy = (hoop.y - ball.y - 0.5 * gravity * T * T) / T + heightErr;
}

function update() {
    if (state === "MOVE") {
        ball.z = 50; // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –¥–ª—è MOVE
        ball.x = playerPos;
        ball.y = FLOOR_Y - ball.z * 1.5;
    }
    if (state === "AIM_LINE") {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–ª—å –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
        const distToHoop = Math.sqrt(Math.pow(hoop.x - ball.x, 2) + Math.pow(hoop.y - ball.y, 2));
        aimTargetX = ball.x + Math.cos(aimAngle) * distToHoop;
        aimTargetY = ball.y - Math.sin(aimAngle) * distToHoop;
    }
    if (state === "TIMING") {
        powerPoint += powerDir;
        if (powerPoint > 1 || powerPoint < 0) powerDir *= -1;
    }
    if (state === "SHOT" && ball.active) {
        ball.x += ball.vx; ball.y += ball.vy; ball.z += ball.vz; ball.vy += gravity;
        if (ball.z >= hoop.z && !ball.bounced) {
            ball.bounced = true;
            const xDist = Math.abs(ball.x - hoop.x);
            if (ball.isPerfect && xDist < 55) {
                ball.vz = 0; ball.vx *= 0.1; ball.vy = 2; score += 3;
                resultText = "–ü–û–ü–ê–î–ê–ù–ò–ï! +3"; playSound(800, 0.4); vibrate(40);
            } else {
                ball.vz *= -0.6; ball.vy = -3; ball.vx += (Math.random()-0.5)*12;
                resultText = "–ü–†–û–ú–ê–•"; playSound(150, 0.2); vibrate([50, 50, 50]);
            }
        }
        if (ball.y >= FLOOR_Y) { ball.y = FLOOR_Y; ball.active = false; state = "RESULT"; }
    }
}

/* ================= RENDER ================= */
function drawButton(btn, text, color = "rgba(255,255,255,0.7)", textColor = "black") {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(btn.x, btn.y, btn.w, btn.h, 10);
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.fillStyle = textColor;
    ctx.font = `bold ${btn.h * 0.5}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, btn.x + btn.w / 2, btn.y + btn.h / 2);
}

function drawShootButton() {
    const btn = buttons.shoot;
    ctx.save();
    ctx.shadowColor = "rgba(255,255,0,0.8)";
    ctx.shadowBlur = (state === "MOVE" || state === "AIM_LINE" || state === "TIMING") ? 15 : 0;
    
    ctx.fillStyle = (state === "TIMING" && powerPoint > 0.75) ? "#00ff00" : "orange";
    ctx.beginPath();
    ctx.arc(btn.x + btn.w / 2, btn.y + btn.h / 2, btn.w / 2 - 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    ctx.stroke();

    ctx.fillStyle = "black";
    ctx.font = `bold ${btn.h * 0.3}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("–ë–†–û–°–û–ö", btn.x + btn.w / 2, btn.y + btn.h / 2);
    ctx.restore();
}

function drawParabolaPath() {
    const startX = ball.x, startY = ball.y;
    const targetX = aimTargetX; 
    const targetY = aimTargetY;

    const cpX = (startX + targetX) / 2;
    const cpY = Math.min(startY, targetY) - 220; 

    ctx.save(); ctx.shadowColor = "white"; ctx.shadowBlur = 4;
    ctx.setLineDash([8, 8]); ctx.strokeStyle = "black"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.quadraticCurveTo(cpX, cpY, targetX, targetY); ctx.stroke(); ctx.restore();

    if (state === "TIMING") {
        const t = powerPoint;
        const dotX = (1-t)*(1-t)*startX + 2*(1-t)*t*cpX + t*t*targetX;
        const dotY = (1-t)*(1-t)*startY + 2*(1-t)*t*cpY + t*t*targetY;
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(dotX, dotY, 15, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = t > 0.75 ? "#00ff00" : "#ff0000"; ctx.beginPath(); ctx.arc(dotX, dotY, 10, 0, Math.PI*2); ctx.fill();
    }
}

function draw() {
    ctx.clearRect(0, 0, W, H);
    ctx.drawImage(courtImg, 0, 0, W, H);
    
    // –¢–µ–Ω—å
    ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath();
    ctx.ellipse(ball.x, FLOOR_Y, 45 * (1-ball.z/200), 15 * (1-ball.z/200), 0, 0, Math.PI*2); ctx.fill();

    if (state === "AIM_LINE" || state === "TIMING") drawParabolaPath();

    // –ú—è—á
    ctx.beginPath(); ctx.fillStyle = (ball.isPerfect && ball.active) ? "#00ff66" : "orange";
    ctx.arc(ball.x, ball.y, ball.r * (1-ball.z/250), 0, Math.PI*2); ctx.fill(); 
    ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.stroke();

    // UI
    ctx.save(); ctx.fillStyle = "black"; ctx.font = "bold 34px Arial"; ctx.shadowColor = "white"; ctx.shadowBlur = 10;
    ctx.fillText("–°–ß–ï–¢: " + score, 40, 60); ctx.restore();

    if (state === "RESULT") {
        ctx.textAlign = "center"; ctx.font = "bold 75px Arial"; ctx.fillStyle = "black";
        ctx.shadowColor = "white"; ctx.shadowBlur = 12; ctx.fillText(resultText, W/2, H/2); ctx.textAlign = "left";
    }

    // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    if (state === "MOVE") {
        drawButton(buttons.left, "‚óÄ");
        drawButton(buttons.right, "‚ñ∂");
    } else if (state === "AIM_LINE") {
        drawButton(buttons.aimLeft, "‚ñ≤"); // –°—Ç—Ä–µ–ª–∫–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —É–≥–ª–∞ –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
        drawButton(buttons.aimRight, "‚ñº");
    }
    drawShootButton(); // –ö–Ω–æ–ø–∫–∞ –±—Ä–æ—Å–∫–∞ –≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º–∞

    requestAnimationFrame(draw);
}

courtImg.onload = () => draw();
update();
</script>
</body>
</html>
